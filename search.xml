<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>指针的运算</title>
      <link href="/2024/04/04/%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97/"/>
      <url>/2024/04/04/%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p><strong>对于一些教材上说：</strong></p><p>指针的指针就是指向指针的指针<br>结构指针就是指向结构的指针<br>数组指针就是指向数组的指针<br>函数指针就是指向函数的指针<br>当你看到函数指针时，指针之间的运算你就已经突破了。</p><p><strong>对这些说法展开的讨论：</strong></p><p>那这个定义这么写的话，是不是就可以问：指针的指针就一定要指向一个指针，结构指针就一定要指向一个结构…..</p><p><strong>1.先看指针的指针，就是二级指针。</strong><br>指针是一种新的数据类型，既然是数据类型，就要知道他的宽度。到目前为止，在32位系统下只要是 * 类型即时4字节，别急，往下看，先来看二级指针的写法：</p><pre><code class="c++">int  a = 1;     //声明一个变量aint *p = &amp;a;    //声明一个指针p指向a的地址；int **pp=&amp;p;    //声明一个二级指针指向p的地址，此时，如果要打印**pp指向的值，那就是1；</code></pre><p>在来看一下指针间的运算，运算要在类型确定的情况下才能够进行运算；a - b 的值就等于（a - b）的值 &#x2F; 类型去掉一个 * 号后类型的大小；</p><p>指针加数字&#x2F;指针减数字</p><pre><code class="c++">char* p = (char*)10;printf(&quot;%d&quot;,p+1);char* p=(char*)10;printf(&quot;%d&quot;,p-1);打印出来的就是11，char*</code></pre><p> 类型去掉一个 * 之后的大小就是1；那如果p的类型是int* 类型，那打印出来的就是14;减法是同样的道理，</p><p>指针减指针：</p><pre><code class="c++"> int arr[10] = &#123; 0 &#125;; int *p = &amp;arr[1];     //x+4 int *q = &amp;arr[6];     //x+24 printf(&quot;%d\n&quot;, p - q);//-5</code></pre><p>计算时，要先计算出被减数和减数之间有多少字节，然后用这个字节在除以类型去掉一个 * 之后的大小；所以计算完是-5；那能做减法，能做加法吗？  对于指针来说，地址是编译器分配的，不能确定俩个指针相加完之后的值在不在有效内存上，如果强行让其相加的话，也是可以的，但是没有意义，你的工作是为了利用计算机解决问题，现在好了，你用问题把计算机解决掉了！（补充一点知识，从汇编指令上看，强制转换并不产生实际的计算指令，感兴趣可以去研究一下）</p><p>现在来提升难度，感受被指针支配的恐惧；</p><pre><code class="c++">char* a1;char** a2;char*** a3;printf(&quot;%d\n&quot;,*(a1+2));//+2printf(&quot;%d\n&quot;,a1[2]);    //+2</code></pre><p>打印的俩种语句的反汇编是一样的，可以自己打印一下，这就说明，数组的计算和指针的技术方式是一样的；他们都是加二，如果把a1替换成a2呢，先char**减去一个 * ，类型大小时4，加2就是加俩个大小为4的类型，就是+8；再来看一种：</p><pre><code class="c++">printf(&quot;%d\n&quot;,*(*(a2+2)+3));</code></pre><p>难度上升了一个维度，a2+2加的是8，上一句已经解释了为什么，那来看+3,现在*(a2+2)整体的类型是什么，a2的类型是char** ,那*(a2+2)的类型就是char<em>类型，char</em>类型的值+3就是将char<em>减去一个</em>之后的类型大小，为1，所以就是+3,最后的大小就是a1+8+3;</p><pre><code class="c++">printf(&quot;%d\n&quot;,*(*(*(a3+3)+4)+5));</code></pre><p>难度看似有上升了，真的是这样吗？和上边的计算方法如出一辙，它最后的运算是+12+16+5；</p><p>相信我，当你已经不再害怕看到这些东西的时候，那你指针的瓶颈就已经突破了；当你掌握了方法，再多的括号都不是事；</p><p>那现在来回头看上面的代码，仔细看第一步的俩个printf，俩种语句汇编是一样的，所以，下边的俩个printf分别是a2[2][3]，a3[3][4][5]，到现在，你已经学完了一维数组，二维数组，三维数组，那在高维的计算还能不会吗，事实上也不会有人回去声明3维以上的数组的；这些维度的数组计算方式一样的原因是  计算机在实现这些多维数组时，在底层都是一维数组的声明方式，所谓的维度完全是为了方便开发人员，和计算机无关；</p><p>2.结构体指针</p><pre><code class="c++">struct str&#123;int a;int b;&#125;int main()&#123;    str* p;//结构体指针    p++;&#125;</code></pre><p>结构体用好几种不同的声明类型，文章只介绍结构体类型的运算，不包括内存对齐，声明类型这些东西：</p><p>可以计算结构体指针加数字或者减数字，先算出结构体类型的大小，和上别的指针加减法师一样的，str结构体大小为8，那计算就以8为单位计算；</p><p>3.数组指针<br>声明类型为int (<em>p)[ 5 ]，这个要和指针数组区分开，指针数组声明方式是int</em> p[5],因为[]运算符的优先级大于 * ，所以它的重点是数组；而()的优先级大于[],重点强调的是指针，所以前一种类型就是数组指针；</p><pre><code class="c++">int main()&#123;    int (*px)[5];    printf(&quot;%d\n&quot;,sizeof(px));    px=10;    px++；     printf(&quot;%d&quot;,px);&#125;来看sizeof(px)会输出多少，想要知道输出多少，就要知道px的数据类型，每种变量，最重要的就是它的类型。px的类型为int (*</code></pre><p>)[5],那它的类型大小就是20，在看下一行的赋值语句，这一行是通不过编译 的，因为10的类型和px的类型不一样，需要强制转换一下：</p><p>px&#x3D;(int (<em>)[5])10;这样才能通过编译；再下一行px++，相当于px+1,上边的指针运算，int (</em>)[5]类型去掉一个 * 之后是int[5],类型大小为20，所以最后输出的px位30；换成char类型也是同样的道理，就是类型大小编程了1,；</p><p>那现在提升难度，多维数组指针，写法是int (*p)[5][5];如果已经了解了多维指针和数组指针，那这个就可以理解为这两种指针类型的结合体，计算方式也八九不离十。直接上题：</p><pre><code class="c++">char str1[]=&#123;0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,            0x19,0x11,0x21,0x34,0x23,0x75,0x21,0x33,0x12,0x23&#125;;int main()&#123;    int (*p1)[5];                //一维数组指针    p1 = (int (*)[5])str1;        //给p1赋值    printf(&quot;%x\n&quot;,*(*(p1+2)+3));    char (*p2)[3][4];            //二维数组指针声明    p2 = (char (*)[2][3])str1;   //给p2赋值    printf(&quot;%x\n&quot;,*(*(*(p2+2)+3)+4));&#125;</code></pre><p>那就直接说答案了：第一个输出的是4<em>2</em>5*+4<em>3</em>5 &#x3D; …..不好意思！越界了，数有点大；算术中的4是int的类型大小。就假装得到的值是20，在数组中数的时候，因为是char类型，但是p1是int类型，输出的是 23123321，这里还有一个知识点，就是现在大部分的windows设备都是采用小端存储，就是低地址在高位；</p><p>在来看下边的p2：计算方式是：1<em>2</em>3<em>2+1</em>2<em>3</em>3+1<em>2</em>3<em>4 &#x3D; ……还是比较大，算术中的1代</em>表char类型大小，紧跟着的2*3是数组的[2][3]，2就是+2了，后边也是一样的计算方式；</p><p>从代码中还可以总结到，一维数组想要取值需要俩个 * ，二维数组想要取值需要三个 *；</p><p>4.函数指针<br>先来看函数指针的写法：int (*pFuntion)(int,int);最重要的 它的宽度是  4。</p><pre><code class="c++">int main()&#123;     int (*pFunction)(int,int);    pFunction=(int (__cdecl *(int,int)))10;//赋值语句；&#125;赋值需要转换的类型就是pFunction的类型，这里又有一个小知识，__</code></pre><p>cdecl是编译器默认的调用约定，参数传递是从右向左，默认的，所以不写也可以；</p><p>也可以这样赋值：</p><pre><code>int func(int a,int b)&#123;    return a+b;&#125;int main()&#123;     int (*pFunction)(int,int);    pFunction=func;//赋值语句；&#125;</code></pre><p>这样应该也能够看懂吧，func的类型正好是(int (*(int,int)))类型，所以不需要强制转换；</p><p><strong>函数指针运算</strong></p><p>加法：进行运算时，要先去掉一个 * 在进行运算，但是，在去掉之后还能确定函数宽度吗？函数的宽度可能是变化的，所以不能进行加法运算，</p><p>减法：emmmmm……让你们失望了，他也不能做减法运算，道理是一样的；又有一个小知识，函数也是全局变量；和找全局变量的 方式是一样的；</p><p>但是，看着这个函数指针确有点鸡肋，不知道什么时候用它，我来总结一下他一般用在什么地方：</p><pre><code class="c++">#include &lt;stdio.h&gt;  //Calculate用于计算积分。一共三个参数。第一个为函数指针func，指向待积分函数。二三参数为积分上下限  double Calculate(double(*func)(double x), double a, double b)  &#123;      double dx = 0.0001;//细分的区间长度      double sum = 0;      for (double xi = a+dx; xi &lt;= b; xi+=dx)      &#123;         double area = func(xi)*dx;         sum +=area;      &#125;      return sum;  &#125;  double func_1(double x)  &#123;      return x*x;  &#125;  double func_2(double x)  &#123;      return x*x*x;  &#125;  void main()  &#123;      printf(&quot;%lf\n&quot;, Calculate(func_1, 0, 1));      printf(&quot;%lf\n&quot;, Calculate(func_2, 0, 1));  &#125;  </code></pre><p>这个是我看别人的…..,原文链接在这里</p><p><a href="https://blog.csdn.net/wudidajundui/article/details/80411594?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161779085016780274117123%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161779085016780274117123&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-80411594.pc_search_result_cache&utm_term=%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%94%A8%E5%A4%84&spm=1018.2226.3001.4187">https://blog.csdn.net/wudidajundui/article/details/80411594?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161779085016780274117123%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=161779085016780274117123&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-80411594.pc_search_result_cache&amp;utm_term=%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%94%A8%E5%A4%84&amp;spm=1018.2226.3001.4187</a><br>这个例子确实很经典，但是还有一个就是在加载dll的时候，动态调用dll中的函数可以保证和 dll 中需要调用的函数申明一致；</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>备用APC</title>
      <link href="/2024/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%B9%E7%A7%BB%E4%BD%8D%E7%AC%A6%E7%9A%84%E5%A4%84%E7%90%86/"/>
      <url>/2024/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%B9%E7%A7%BB%E4%BD%8D%E7%AC%A6%E7%9A%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<ul><li>&lt;如果图片长时间未显示，可能需要魔法&gt;</li></ul><p><strong>1.先说一个运算口诀叫“左乘右除”，如k&lt;&lt;1&#x3D;&#x3D;&gt;k*2; k&gt;&gt;1&#x3D;&#x3D;&gt;k&#x2F;2;</strong></p><p><strong>2.左移</strong><br>先看左移运算，因为相对于右移较为简单；<br>x向左移动K位，会丢弃最高的K位，并在右端补K个0，移位运算是从左到右课结合的，所以x&lt;&lt;j&lt;&lt;k等价于(x&lt;&lt;j)&lt;&lt;k;</p><p><strong>3.右移</strong><br>而对于右移运算，x&gt;&gt;K,一般而言，机器支持俩种右移方式，逻辑右移和算术右移，逻辑右移在左端补K个0，而算术右移在左端补K个最高有效位的值，这种方式对于有符号的运算是非常有效的，</p><p>来看一个数据：</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041622955.png"></p><p>斜体的数值表示位刚填充的数值；可以看到除一个条目外，其余都是补0，唯一的不同是算术右移的【10010101】，因为操作数的最高位位1，所以补1；</p><p>但是C标准并未定义有符号数要使用那种运算方式，这就意味着任何假设一种或者另一种右移形式的代码都会影响到代码的可移植性，然而，所有的机器组合都对有符号数使用算术右移，并且程序员也会假设使用这种方式；另一方面，对于无符号数，右移必须是逻辑运算；</p><p>但是对于Java来说，就与明确的定义，x&gt;&gt;k,表示使用算术运算右移k，而逻辑运算表示为x&gt;&gt;&gt;k;</p><p>还有一种情况是：当K值很大，已经超出了int类型的取值范围，这时应该怎么办？（在32位系统中）<br>其实C语言已经给这种情况做了规避，当移动K位时，移位指令只考虑位移量的低log2(K),当K为32时，相当于移位0，K位34时，相当于移位2；但是这种方法在C语言中时没有保证的，就是这种方式没有被C严格规定；</p><p>先来了解一下什么是位模式，后边会用到，<br>我们都知道，计算机内存里只能存储0和1俩种数字，这就需要把别的数据都转换成二进制数字，在根据计算机所能存储的容量来决定最小的存储单元进行存储，这是位模式的存储方式；所以可以将位模式理解为就是计算机存储不同数据的一种数据表示方法；</p><p>再来了解一个东西，数学术语中的双射，后边会用到；<br>是指一个函数( F() )有俩面，将数值x映射为数值y，就是y&#x3D;F(x),对于y，有唯一一个数x使等式成立；这里的y和x反向操作也同样成立，这种方式理解为双射；</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041622080.png"></p><p>需要注意的是，不同的机器对long的取值范围有不同的规定；图中显示，负数的取值范围会比正数的大1，那么，为什么会这样？这时候会引伸出另外一个问题，负数怎么表示？</p><p>4.补码编码</p><p>计算机表示负数的方式就是补码，在这个定义中，将字的最高有效位解释为字权，用函数B2T(ω)表示，二进制转补码；公式：</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041623959.png"></p><p>ω为4时，也就是长度设为4，可以取到极值，<br>最小值是TMin(4) &#x3D; B2T(4)([1000])&#x3D; -2^3&#x3D;-8;<br>最大值是TMax(4) &#x3D; B2T(4)([0111]);</p><p>111转为10进制为7，这就是负数的取值范围为什么会比正数大1的理论基础：<strong>有一半的位模式（符号位设置为1的数）表示负数，而另一半（符号位设置为0的数）表示非负数。因为0是非负数，就意味着能表示的整数比负数少一个；</strong></p><p>可以看出来B2T(ω)是一个长度从w的位模式到TMin(w)和TMax(w)之间数字的映射，同无符号表示一样，在可表示的取值范围内的每个数字都有唯一一个ω位的补码编码，这就导出了与无符号数相似的补码原理：<strong>补码编码的唯一性；</strong></p><p>函数T2B(ω)作为B2T(ω)的反函数，对于每个数x，满足TMin(ω)&lt;&#x3D;x&lt;&#x3D;TMax(ω)；<br>则T2Bω(x)是x的ω位模式；</p><p>C 语言允许无符号数和有符号数之间的转换，大多数系统遵循的原则是底层的位保持不变；在一台采用补码的机器上，当从无符号数转换成有符号数时，就是应用函数U2Tω，从有符号数转换成有符号数时，应用函数T2Uω;ω表示数据类型的位数；</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RTSP协议基础详解</title>
      <link href="/2024/04/04/RTSP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/04/04/RTSP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<ul><li>&lt;如果图片长时间未显示，可能需要魔法&gt;</li></ul><p><strong>一，基础内容</strong><br>定义：RTSP（Real Time Streaming Protocol），实时流传输协议，是TCP&#x2F;IP协议体系中的一个应用层协议，该协议定义了一对多应用程序如何有效地通过IP网络传送多媒体数据。<br><strong>特点：</strong></p><ol><li>RTSP在体系结构上位于RTP和RTCP之上，它使用TCP或UDP完成数据传输。</li><li>HTTP与RTSP相比，HTTP请求由客户机发出，服务器作出响应；</li><li>使用RTSP时，客户机和服务器都可以发出请求，即RTSP可以是双向的。</li><li>RTSP是用来控制声音或影像的多媒体串流协议，并允许同时多个串流需求控制，传输时所用的网络通讯协定并不在其定义的范围内，服务器端可以自行选择使用TCP或UDP来传送串流内容，它的语法和运作跟HTTP</li><li>1.1类似，但并不特别强调时间同步，所以比较能容忍网络延迟。</li><li>1.RTSP协议是基于RTP和RTSP之上的；</li><li>RTSP使用RTP传输媒体数据，使用RTCP来控制交互命令；</li></ol><p><strong>RTSP控制命令交互格式：</strong><br>控制端：</p><pre><code class="c++">Method url version\r\ncCSeq: x\r\n   \r\n   ...</code></pre><p>Method表示具体的方法；<br>url是请求地址，一般为rtsp:&#x2F;&#x2F;ip:port&#x2F;session,默认554端口；<br>version表示版本；大家都在发大家都在发大家都在发；<br>CSeq表示序列号；</p><p>服务器响应格式：</p><pre><code class="c++">Version 200 OK\r\nCSeq:x\r\n...\r\n...\r\n</code></pre><p>200遵循http协议的状态码 200表示成功；</p><p><strong>二，协议内容</strong></p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041615073.png"></p><p>OPTIONS方法：获取服务端提供的可用方法；</p><pre><code class="c++">Client--&gt;Server发送OPTIONSOPTIONS rtsp://127.0.0.1:554/live RESP/1.0\r\nCSeq: 1\r\n\r\n</code></pre><p>服务器回应可用方法到客户端；<br>DESCRIBE方法：获取对应回话的媒体描述信息；<br>Client–&gt;server</p><pre><code class="c++">DESCRIBE rtsp://127.0.0.1:554/live RTSP/1.0\r\nCSeq: 2\r\nAccept: application/sdp\r\n\r\nv=0\r\n</code></pre><p>SETUP方法：向服务器发起建立请求，建立连接会话；\</p><pre><code class="c++">Sercer-&gt;ClientSETUP rtsp://127.0.0.1:554/live/track0 RTSP/1.0r\r\nCSeq: 3\r\nTransport: RTP/AVP;unicast;client_port=50000-50001\r\n\r\n</code></pre><p>track:为轨道，需要获取；<br>RTP&#x2F;AVP表示UDP发送，如果是RTP&#x2F;AVP&#x2F;TCP则表示RTP通过TCP发送；<br>Unicast表示单播，multicast表示多播；<br>Client_port表示50000是RTP端口，50001表示RTCP端口，都是UDP套接字；</p><pre><code class="c++">server--&gt;clientRTSP/1.0 200 OK\r\nCSeq: 3\r\nTransport: RTP/AVP;unicast;client_port=50000-50001;server_port-55000-55001\r\nSession: &quot;八位整数&quot;\r\n   //一般为时间戳\r\n</code></pre><p>server_port表示服务器使用这俩个端口传输数据，55000是RTP，55001是RTCP端口；<br>PLAY方法：想服务器发起播放请求；</p><pre><code class="c++">client--&gt;server;PLAY rtsp:127.0.0.1:554/live RTSP/1.0\r\nCSeq: 4\r\nSession: &quot;八位整数&quot;\r\nRange: npt=0.000-\r\n\r\n</code></pre><pre><code class="c++">server--&gt;clientRTSP/1.0 200 OK\r\nCSeq: 4\r\nRange: npt=0.000-\r\nSession: “八位整数”;timeout=60\r\n\r\n</code></pre><p>服务器回复数据之后，会向客户端的RTP端口（50000）发送数据，最后，执行最后一步；</p><p>TEARDOWM方法：想服务器发起关闭连接会话请求；</p><pre><code class="c++">client--&gt;serverTEARDOWN rtsp://127.0.0.1:554/live RTSP/1.0\r\nCSeq: 5\r\nSession: &quot;八位整数&quot;\r\n\r\n</code></pre><pre><code class="c++">server--&gt;clientRTSP/1.0 200 OK\r\nCSeq: 5\r\n\r\n</code></pre>]]></content>
      
      
      <categories>
          
          <category> 协议 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程调度重点笔记</title>
      <link href="/2024/04/04/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E9%87%8D%E7%82%B9%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/04/04/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E9%87%8D%E7%82%B9%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>进程调度重点笔记</strong></p><p>1.进程调度追求的目标是什么？<br>达到极小化平均响应时间、极大化系统吞吐率、保存系统各个功能部件处于繁忙状态和提供某种貌似公平的机制。但是，对于不同的操作系统来说达到的目的也会不同。对于批处理系统，不注重用户等待时间。交互式系统要对于响应时间要适当；</p><p>2.程序使用CPU的模式有哪几种？它们的特点；</p><p>在CPU上执行较长时间；<br>这种称为CPU导向或计算密集型程序，通常用于科学计算方面的程序；<br>CPU执行时间短，大部分用于I&#x2F;O操作；<br>称为I&#x2F;O导向或者输入输出密集型程序；人机交互式到属于这类程序，如游戏程序以及PPT程序；<br>介于二者之间，有较长的CPU执行时间，较长时间的I&#x2F;O操作；<br>称为平衡型程序；如网络浏览器，网络视屏；<br>3.保障调度和时间片轮转的异同点，根本区别是什么？<br>时间片轮转：目的是改善短程序的响应时间，周期性的进行进程切换；其实就是对FCFS算法的改进，一个程序运行一个时间段就切换给别的进程，让个程序都有机会运行；但是频繁的进程切换需要消耗系统时间（切换时间需要把控)；<br>保障调度：就是保障每个进程都能拿到1&#x2F;n的CPU时间；但是可以不需要轮转就能实现；</p><p>根本区别就是保障调度可以不需要轮转，每次给的时间片不一定要一样；<br>4.什么是优先级倒挂？他有什么危害？<br>一个低优先级任务持有一个被高优先级认为所需要的共享资源；这样高优先级任务资源缺乏而受阻，一直到低优先级任务释放资源为止；<br>某些时候并不会造成危害，等到低优先级任务结束后，资源自然会给到高优先级任务；<br>如果阻碍任务较为重要，就可能会导致系统报错；</p><p>5.怎么解决优先级倒挂？<br>优先级倒挂的俩种形式：</p><p>不持有资源的低优先级进程阻碍需要资源的高优先级进程的执行；<br>持有资源的低优先级进程阻碍需要资源的高优先级进程的执行；<br>第一种形式的解决办法：使用中断禁止；<br>通过禁止中断来保护临界区，这种方式会出现俩个优先级：可抢占优先级和中断禁止优先级。前者为一般进程运行时的优先级，后者为运行于临界区进程的优先级。由于系统的锁不能发生乱序，不会发生死锁。又由于进入临界区的进程总是能够不被打断而一直运行到结束，因此也不会发生悬挂；这样，技术高优先级进程采用繁忙等待也不会发生死锁；但是，所用种啊段都必须禁止，如果禁止的只是一个硬件设备中断，能硬件的中断优先处理机制将再次引入优先级倒挂；<br>在多CPU环境下，不能使用中断禁止，就有另外一种方式，单一共享标志锁，<br>第二种形式的解决办法：优先级上限(priority ceiling)<br>中断禁止可以防止第一种优先级倒挂，但是无法避免第二种。想要避免就不能让低优先级进程持有高优先级进程所需要的资源。思路就是让共享的临界区有自己的优先级，并让访问临界区的进程获得临界区的优先级，只要临界区的优先级设置的够高，就可以避免；但是试图访问mutex的程序具有高于mutex的优先级还是可能发生倒挂；</p><p>要完全杜绝倒挂，就需要在任何时候都确保等待资源的进程具有的优先级必须低于持有资源的进程的优先级。如何实现呢？就是优先级继承（priority inheritance）:<br>当一个高优先级进程等待一个低优先进程所持有的资源时，这个低优先级进程抢占低优先级进程而延长资源占用时间，同时也防止了因高优先进程自身进行繁忙等待可能导致的死锁。在释放共享资源后，低优先级进程回到其原来的优先级别；<br>6.如果最后一个进程在CPU任务结束后由很长一段时间的I&#x2F;O操作，在计算CPU响应时间时是否应该计入该I&#x2F;O操作耗时？<br>不算；<br>具体原因…</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows系统应用提权</title>
      <link href="/2024/04/04/windows%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E6%8F%90%E6%9D%83/"/>
      <url>/2024/04/04/windows%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<ul><li>&lt;如果图片长时间未显示，可能需要魔法&gt;</li></ul><h2 id="应用提权"><a href="#应用提权" class="headerlink" title="**应用提权 **"></a>**应用提权 **</h2><p><strong>内置用户：</strong><br>Administrator，系统管理员账户，拥有完全控制权限。<br>Guest，来宾账户，供访问共享资源的网络用户使用，仅具有最基本权限，默认被禁用。</p><p><strong>内置用户组：</strong><br>Administrators，管理员组。<br>Users组，新建用户默认所属的组。<br>Guests组，权限最低；</p><p>开发环境是VS2019；</p><p>我先做了权限判断，如果不需要请跳过；看代码：<br>1.信息展示</p><pre><code class="c++">void ShowError()&#123;    LPWSTR lpMessageBuf = NULL;    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,        NULL, GetLastError(),        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),        (LPWSTR)&amp;lpMessageBuf, 0, NULL);    OutputDebugString(lpMessageBuf);    LocalFree(lpMessageBuf);&#125;</code></pre><p>这是一个准备函数，用来展示错误信息；<br>lpMessageBuf:设置一个缓冲区；<br>FormatMessage：它的功能就是将GetLastError函数得到的错误信息（这个错误信息是数字代号）转化成字符串信息的函数。</p><pre><code class="c++">FormatMessage (      DWORD dwFlags, // 标志位      LPCVOID lpSource, //根据dwFlags标志而定。      DWORD dwMessageId, // 请求的消息的标识符      DWORD dwLanguageId, // 请求的消息的语言标识符。      LPTSTR lpBuffer, // 接收错误信息描述的缓冲区指针。      DWORD nSize,       // 如果FORMAT_MESSAGE_ALLOCATE_BUFFER标志没有被指定，这个参数必须指定为输出缓冲区的大小，如果指定值为0，这个参数指定为分配给输出缓冲区的最小数      va_list *Arguments // 保存格式化信息中的插入值的一个数组。               );</code></pre><p>剩下俩个函数就是输出和关闭lpMessageBuf;<br>2，判断管理员权限</p><pre><code class="c++">bool IsAdmin()&#123;    HANDLE Token = NULL;    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &amp;hToken))    &#123;        ShowError();        return false;    &#125;    TOKEN_ELEVATION eve;    DWORD len = 0;    if (GetTokenInformation(Token, TokenElevation, &amp;eve, sizeof(eve), &amp;len) == false)    &#123;        ShowError();        return false;    &#125;    CloseHandle(Token);    if (len == sizeof(eve))    &#123;        return eve.TokenIsElevated;    &#125;    TRACE(&quot;length of tokeninformation is %d\r\n&quot;, len);    return false;</code></pre><p>OpenProcessToken:函数用来打开与进程相关联的访问令牌。</p><pre><code class="c++">BOOL OpenProcessToken(__in HANDLE ProcessHandle, //要修改访问权限的进程句柄__in DWORD DesiredAccess, //指定你要进行的操作类型__out PHANDLE TokenHandle //返回的访问令牌指针)；</code></pre><p>GetCurrentProcess:获取当前进程的一个伪句柄;对本进程进行操作的时候，没有必要通过枚举获得当前进程的句柄。通过GetCurrentProcess函数来获得一个伪句柄，并可以做为参数传入我们要调用的函数中。</p><p>GetTokenInformation：进程是否具有管理员权限；</p><pre><code class="c++">GetTokenInformation(_In_ HANDLE TokenHandle,//令牌指针_In_ TOKEN_INFORMATION_CLASS TokenInformationClass,//从TOKEN_INFORMATION_CLASS枚举类型的值来确定函数检索的信息类型_Out_writes_bytes_to_opt_(TokenInformationLength, *ReturnLength) LPVOID TokenInformation,//缓冲区指bai针函数填充所请求的信息。 投入这个缓冲区结构取决于指定的类型的信息_In_ DWORD TokenInformationLength,//指定的大小，以字节为单位指向第三个参数。如果为NULL，这个参数必须为零。_Out_ PDWORD ReturnLength//其接收所需的第三个参数指向的缓冲区的字节数);</code></pre><p>总结就是：先拿到Token-&gt;通过Token拿information；根据information判断结果；</p><p>开始提权<br>提权分俩步：获取管理员权限 使用管理员权限创建进程；<br>我的系统是win10教育版，不同的版本LogonUser参数可能会有一点下的出入；先看demo</p><pre><code class="c++">void RunAdmin()&#123;    //获取管理员权限，使用该权限创建进程；    HANDLE Token = NULL;    BOOL ret = LogonUser(L&quot;Administrator&quot;, NULL, NULL, LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT, &amp;Token);    if (!ret)    &#123;        ShowError();        MessageBox(NULL, _T(&quot;登录错误！&quot;), _T(&quot;程序错误&quot;), 0);        exit(0);    &#125;    OutputDebugString(L&quot;Logon administrator success!\r\n&quot;);    STARTUPINFO si&#123; 0 &#125;;    PROCESS_INFORMATION pi&#123; 0 &#125;;    TCHAR sPath[MAX_PATH] = _T(&quot;&quot;);    GetCurrentDirectory(MAX_PATH, sPath);    CString strCmd = sPath;    strCmd += _T(&quot;\\RemoteCtrl.exe&quot;);    ret = CreateProcessWithTokenW(hToken, LOGON_WITH_PROFILE, NULL, (LPWSTR)(LPCWSTR)strCmd, CREATE_UNICODE_ENVIRONMENT, NULL, NULL, &amp;si, &amp;pi);   //直接登录方式    //ret=CreateProcessWithTokenW(_T(&quot;Adminostrator&quot;),NULL,NULL, LOGON_WITH_PROFILE, NULL, (LPWSTR)(LPCWSTR)strCmd, CREATE_UNICODE_ENVIRONMENT, NULL, NULL, &amp;si, &amp;pi,)    CloseHandle(Token);    if (!ret)    &#123;        ShowError();        MessageBox(NULL, _T(&quot;创建进程失败&quot;), _T(&quot;程序错误&quot;), 0);        exit(0);    &#125;    WaitForSingleObject(pi.hProcess, INFINITE);    CloseHandle(pi.hProcess);    CloseHandle(pi.hThread);&#125;</code></pre><p>LogonUser:调用这个函数试图用一个用户名来登录本台计算机,如果登录成功，返回一个句柄；</p><pre><code class="c++">BOOL LogonUser(  LPTSTR lpszUsername,  LPTSTR lpszDomain,  LPTSTR lpszPassword,  DWORD dwLogonType,  DWORD dwLogonProvider,  PHANDLE phToken);</code></pre><p>返回值：<br>返回1：登录成功，并会得到phToken句柄，返回0：登录失败。<br>参数类型及说明：</p><p>lpszUsername：登录的用户名 lpszDomain：要登录的计算机，如果为。或者NULL则是登录本机<br>lpszPassword：登录密码 dwLogonType：登录方式，类型有：<br>LOGON32_LOGON_INTERACTIVE登录进去还要进行操作。 dwLogonProvider：登录提供，一般为<br>LOGON32_PROVIDER_DEFAULT</p><p>如果失败，弹出错误，结束；<br>申明si和pi的类型是为了在下面CreateProcessWithTokenW函数用到；<br>GetCurrentDirectory：获取当前进程目录；第一个参数是缓冲区，第二个用来存放目录；<br>CreateProcessWithTokenW：使用令牌启动一个新进程；</p><pre><code class="c++">BOOL CreateProcessWithTokenW(  HANDLE                hToken,//令牌句柄  DWORD                 dwLogonFlags,//登录选项  LPCWSTR               lpApplicationName,//要执行模块名称  LPWSTR                lpCommandLine,//要执行的命令行  DWORD                 dwCreationFlags,//控制如何创建过程的标志。  LPVOID                lpEnvironment,//指向新进程的环境块的指针  LPCWSTR               lpCurrentDirectory,//进程当前目录的完整路径。该字符串还可以指定UNC路径。  LPSTARTUPINFOW        lpStartupInfo,//指向STARTUPINFO或STARTUPINFOEX结构的指针 。  LPPROCESS_INFORMATION lpProcessInformation//指向PROCESS_INFORMATION结构的指针);</code></pre><p>该函数稍微有点复杂，建议查看文档：</p><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw?redirectedfrom=MSDN">https://docs.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw?redirectedfrom=MSDN</a><br>然后剩下一些收尾工作，关闭句柄，判断是否创建成功；WaitForSingleObject函数等待被创建，然后关闭所有的指针；<br>在main函数下调用就好了；</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>保护模式</title>
      <link href="/2024/04/04/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/04/04/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>&lt;如果图片长时间未显示，可能需要魔法&gt;</li></ul><h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a><strong>保护模式</strong></h2><p>段寄存器（96位）<br>ES CS SS DS FS GS LDTR TR<br>（cs 为代码段寄存器，一般用于存放代码）</p><p>通常和IP 使用用于处理下一条执行的代码<br>cs:IP</p><p>基地址：偏移地址<br>cs地址对应的数据 相当于c语言中的代码语句<br>ds 为数据段寄存器，一般用于存放数据；<br>ds地址对应的数据 相当于c语言中的全局变量<br>ss 栈段寄存器，一般作为栈使用 和sp搭档；<br>ss地址对应的数据 相当于c语言中的局部变量<br>ss相当于堆栈段的首地址 sp相当于堆栈段的偏移地址<br>es 为扩展段寄存器；</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041547182.png"></p><p>在结构体SetVent中</p><pre><code class="c++">  struct SetVent  &#123;        WORD  Selector;//16位        WORD  Attributes; //16位        DWORD  Base; //32位Base        DWORDLimit;//32位Limit  &#125;</code></pre><p>在96位中，只有16位是可见的（Selecter）</p><h3 id="GDT-全局描述符表-LDT-局部描述符表"><a href="#GDT-全局描述符表-LDT-局部描述符表" class="headerlink" title="GDT(全局描述符表) LDT(局部描述符表)"></a><strong>GDT(全局描述符表) LDT(局部描述符表)</strong></h3><p>当执行类似MOV DS,AX指令时，由AX决定查哪张表，在什么位置，查多少数据；<br>段描述符</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041549371.png"></p><p>P位：1 段描述符有效 0 段描述符无效</p><p>Attributes：高四个字节，8位到23位</p><p>Base：由3部分组成，详情看上图；</p><p>Limit：由俩部分组成，见上图；但是还会受G位影响，G位0，Limit单位为字节，位000FFFFF； G位是1时，单位为4kb（1kb&#x3D;1024,以0开始，要减1，换成16进制位FFF）FFFFFFFF</p><p>S位：1 代码段或者数据段描述符；0 系统段描述符；</p><p>S&#x3D;0时的TYPE域</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041550889.png"></p><p>S&#x3D;1时的TYPE域</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041550948.png"></p><p>（数据段A：是否被访问，W是否可写，E为拓展为,1为向下拓展，反之向上拓展，C为一致位，分为一致代码段和非一致代码段）<br>分别为向上拓展和向下拓展，红色部分为有效位</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041550227.png"></p><p>结合段描述符表可知，第一位的第5个字位9或者f就是代码段或数据段</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041551237.png"></p><p>要想确定是代码段还是数据段，看TYPR的第11位，为0是数据段，1为代码段；如果第六个16进制数大于8，就一定是一个代码段，反之位数据段；</p><p>DB位<br>对3个段有影响</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041551816.png"></p><p>段选择子</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041552811.png"></p><p>RPL：请求特权级别</p><p>Index:处理器将索引值乘以8在加上GDT或者LDT的基地址，就是要加载的GDT表的位置；<br>例：001B&#x3D;0000 0000 0001 1011；前俩位11表示RPL；0表示查GDT表，剩下的位为3，</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041552945.png"></p><p>所以往后数4位就是查的位置（从0开始）；</p><p>加载段描述符到段寄存器<br>除了mov,还有LES,LSS,LDS,LFS,LGS修改<br>（cs位代码段，cs修改会导致EIP变化，想要修改cs就要修改EIP）<br>代码间跳转<br>俩种情况：要跳转的段是一致代码段还是非一致代码段</p><p>同时修改CS和EIP的指令有：JMP FAR&#x2F;CALL FAR&#x2F;RETF&#x2F;INT&#x2F;IRETED</p><p>(只改变EIP的指令：JMP&#x2F;CALL&#x2F;JCC&#x2F;RET)</p><p>四种情况下可跳转：代码段，调用门，TSS任务段，任务门；</p><p>权限检查：<br>非一致代码段：CPL&#x3D;&#x3D;DPL &amp;&amp; RPL &lt;&#x3D; DPL;<br>一致代码段：CPL&gt;&#x3D;DPL（希望应用层直接访问就用一致代码段）</p><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>一致代码段（共享的段）：特权级高的程序不允许访问特权级低的程序，但是特权级低的程序允许访问代码段高的程序<br>非一致代码段：只允许同级访问，绝对禁止不同级别访问；</p><p><strong>短调用</strong><br>指令格式：CALL 立即数&#x2F;寄存器&#x2F;内存</p><p>发生改变的寄存器：ESP EIP</p><p><strong>长调用</strong><br>跨段不提权</p><p>指令格式：CALL CS:EIP<br>发生改变的寄存器：EIP ESP CS</p><p><strong>跨段并提权：</strong><br>指令格式:CALL CS: EIP<br>发生改变的寄存器：ESP EIP CS SS</p><p><strong>总结：跨段调用时，一旦有权限切换，就会切换堆栈；<br>CS的权限一旦改变，SS的权限也要发生改变，CS和SS的等级要保持一致；<br>JMP FAR只能跳转到同级非一致代码段，但CALL FAR可以通过调用门提权，提升CPL权限；</strong></p><h3 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a><strong>调用门</strong></h3><p>指令格式：CALL CS:EIP</p><p>执行步骤：1，根据CS的值查GDT表，找到段描述符，这个描述符是一个调用门；<br>2，在描述符中存储另一个代码段的选择子；<br>3，选择子指向的段 段.Base+偏移地址 就是真正要执行的地址。</p><p>门描述符</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041555883.png"></p><p>（Segment Selector指向段的Base+俩个Offset in Segment的偏移；DPL的值除了00，就是11）</p><p>构造一个调用门（无参数）</p><p>0000EC00 00080000，黄标位写入内容的地址，用vs看<br>有参数：0000EC00 00080003(参数需要自己PUSH)</p><p>中断门<br>IDT：中断描述符表；每个描述符表占8个字节，但是IDT表的第一个元素不是NULL；<br>中断门不允许传参数</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041555434.png"></p><p>陷阱门和中断门几乎是一样的，只有描述符结构体的8位到11位是1111，而中端门是1110<br>中断门执行四，将IF位清零，但是陷阱门不会；（IF影响可屏蔽中断）<br>任务门</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041555461.png"></p><p>任务门执行过程：<br>INT N查IDT表，找到中断门描述符在查GDT表，找到任务段描述符使用TSS的值修改寄存器RETD返回；</p><p>TSS：<br>是一快内存，大小104字节，有各种寄存器和段寄存器；当CPU向使用TSS的值时，通过TR寄存器找到TSS；TSS描述符只能通过任务寄存器TR在GDT中解锁，即只有TR可作为TSS的段选择器；<br>确定位置：</p><p>CPU可以通过 gdtr 寄存器来知道 GDT表在哪里，通过 idtr 寄存器知道 IDT 表在哪里。实际上，CPU是通过 tr 寄存器来确定 TSS 的位置的。<br>TSS描述符</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041556883.png"></p><p>当S&#x3D;0, TYPE&#x3D;1001或者TYPE&#x3D;1011的时候，表示这是一个TSS段描述符。当TSS段没被加载进 tr 寄存器时，TYPE&#x3D;1001，一旦TSS被加载进 tr 寄存器，TYPE就变成了1011.</p><p><strong>TSS作用</strong></p><p>保存0环、1环和2环的栈段选择子和栈顶指针<br>一次性切换一堆寄存器<br>把当前所有寄存器（TSS结构中有的那些寄存器）的值填写到当前 tr 段寄存器指向的 TSS 中<br>把新的 TSS 段选择子指向的段描述符加载到 tr 段寄存器中<br>把新的 TSS 段中的值覆盖到当前所有寄存器（TSS结构中有的那些寄存器）中</p><h5 id="页的机制"><a href="#页的机制" class="headerlink" title="页的机制"></a><strong>页的机制</strong></h5><p>10-10-12分页</p><p><strong>1，物理内存</strong></p><p>如下指令：MOV eax,dword ptr ds:[0x123456]<br>其中，0x12345678是有效地址；ds,Base+0x123456是线性地址</p><p><strong>2．设置分页方式（10-10-12）</strong></p><p>例：000AA8A0<br>0000 0000 0000 0101 0101 8A0<br>0000 0000 00 (0)<br>0001 0101 01 (AA)<br>8A0</p><p>将虚拟机boot.ini文件的第一个系统选项noexecute改成execute，然后重启；</p><p><strong>3．找物理地址</strong></p><p>每个进程都有一个CR3，这是唯一一个储存物理地址的寄存器，一共4096个字节；<br>物理内存查看指令：第一级：！dd CR3+0(第一级的CR3通过！process 0 0查看；第二级：！dd CR3+AA4；第三级：！dd CR3+8A4;<br>（注：除了第一级，每级开始前的CR3都要去掉后三位的属性位置才是正确的位置）</p><p><strong>4.PDE和PTE</strong></p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041557303.png"></p><p><strong>PTE特征：</strong>PTE可以没有物理页，PTE可以指向同一个物理页，但是，一个PTE不能有多个物理页；<br>0地址之所以不能读写，是因为没有物理页，挂个有效物理页就能够读写了，那么，什么情况下是有效物理页呢？</p><p><strong>5.物理页的属性</strong><br>物理页的属性&#x3D;PDE属性&amp;PTE的属性</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041557557.png"></p><p>如果P位&amp;后的结果为零，那么这个物理页就是无效物理页<br>（char* str&#x3D;”hello word”,不能通过指针修改的原因是页的性质，属性是只读的；办法：在PDE和PTE里修改R&#x2F;W位）<br>U&#x2F;S位：0 特权用户 1 普通用户</p><p>P&#x2F;S位：支队PDE有意义，当PS&#x3D;1时，PDE直接指向物理页，没有PTE；</p><p>A位：是否被访问过，是就置一；</p><p>D位：是否被写过，写过置1；</p><p>拆分C0300000（页目录基址）</p><p><strong>结论</strong></p><p>C0300000就是PDE的基址，，如果想访问第N个PDE，就会有C0300000+N*4<br>C0300000指向PDE表，但是他本身也是一张PTT表，也是一张物理页；<br>有了这张表,就可以修改任何页目录表；但如果要设置某个线性地址的PDE和PTE，还需要能够访问PTT表，如何访问呢？</p><p>C0000000根据101012分页后，得到的物理页就是第一个PTT表</p><p>C0001000根据101012分页后，得到的物理页就是第二个PTT表</p><p>访问PTE的公式：0xc0300000+PDI*4</p><p>访问PTT的公式：0xc0000000+PDI4096+PTI4</p><p>2-9-9-12分页</p><p><strong>来历：</strong>由于4GB的物理地址范围无法满足要求，提出29912分页，又称PAE（物理地址扩展）分页；<br>只要确定了是4KB，就确定了12，PTT和PDE都是512位，需要9位又可以索引到；2就是拓展之后的；</p><p>开启PAE</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041558837.png"></p><p>原来的物理地址指向的地址发生改变，指向了PDPTE（Page Directory Point Table Entry）表,页目录指针表项，每项占8个字节；</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041557890.png"></p><p>结构：</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041558831.png"></p><p>35—12存储的是页目录表的基址，低12位补0。共36位，即页目录基址；<br>PDE结构</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041558738.png"></p><p>PS位是第7位；<br>PTE结构</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041558918.png"></p><p>XD标志位（AMD称为NX，即No Excetion）<br>为了防止溢出漏洞，Intel做了硬件保护，就是这个不可执行位，XD&#x3D;1时，软件溢出了也没关系，是不可执行的；</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>InLineHook原理笔记</title>
      <link href="/2024/04/04/InLineHook/"/>
      <url>/2024/04/04/InLineHook/</url>
      
        <content type="html"><![CDATA[<ul><li>&lt;如果图片长时间未显示，可能需要魔法&gt;</li></ul><p>InLineHook原理：<br>通过硬编码的方式先内核API的内存空间写入跳转语句，当程序跳转到我们的程序时，需要执行3个步骤：</p><p>1，重新调整当前堆栈；需要保证内核API在执行完代码后返回我们的函数，就需要对当前的堆栈做调整；</p><p>2，执行遗失的指令；执行我们的代码时，可能会覆盖内核API的指令，需要在我们的代码空间将遗失的指令补回来；</p><p>3，信息过滤；根据返回结果做一些信息过滤，这些内容因被hook的API以及hook目的的不同而不同；</p><p>InLineHook工作流程：<br>1.验证内核API的版本</p><p>2.撰写之间的函数，要完成三项任务</p><p>3.获取直接函数的地址，覆盖内核API内存，供跳转</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内存管理重点笔记</title>
      <link href="/2024/04/04/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%87%8D%E7%82%B9%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/04/04/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%87%8D%E7%82%B9%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>&lt;如果图片长时间未显示，可能需要魔法&gt;</li></ul><p>1.内存管理方法<br>固定加载地址的内存管理，<br>固定分区的内存管理，<br>非固定分区的内存管理，<br>交换内存管理。<br>固定加载地址的内存管理只适合单道编程，而其他3种适合多道编程，而且这3种都使用同一种实现机制：基址与极限；<br>基址与极限的工作原理是将程序发出的虚拟地址加上基址而获得物理地址；<br>交换内存管理介绍：<br>虽然这种内存管理方式最灵活和先进，可以解决因程序所需空间增长而无法继续运行的困难，又可以实现多道编程，但是其中最重要的俩个问题是空间浪费和程序大小受限。<br>空间浪费是指空间会被散布在进程之间，称为“外部碎片化”<br>除了这个问题，还有一个问题：地址空间增长困难，这个有俩个意思，1，空间增长效率低下，2.空间增长存在天花板限制。</p><p>解决办法：<br>空间碎片化的根源是每个程序大小不一样，解决办法就是将空间按照一定的大小进行分配。程序增长有限制是因为一个程序需要全部加载到内存才能运行，解决办法就是使一个程序无须全部加载就可以运行，就引出了页的概念，一举俩得；</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>双机调试完整步骤</title>
      <link href="/2024/04/04/%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E5%AE%8C%E6%95%B4%E6%AD%A5%E9%AA%A4/"/>
      <url>/2024/04/04/%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E5%AE%8C%E6%95%B4%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<ul><li>&lt;如果图片长时间未显示，可能需要魔法&gt;</li></ul><p>双机调试完整步骤<br>这样的调试如果不了解的话配置起来会很恶心，本人在配置第一遍的时候踩过很多雷，由于重装了系统，这是第二次装这个双机调试，希望可以帮到你；<br>1.先要下载windbg和XP系统的虚拟机，我这里提供windbg下载资源和XP镜像系统；<br>windbg下载地址:<a href="https://pan.baidu.com/s">https://pan.baidu.com/s</a> &#x2F;1jJULExadpa0neyN7QvL5fw 提取码：2okt<br>XP镜像系统：<a href="https://pan.baidu.com/s/1XAIjNnILF6kd22z9In7aRA">https://pan.baidu.com/s/1XAIjNnILF6kd22z9In7aRA</a> 提取码：noz4</p><p>2.配置boot.ini文件<br>因为文件夹是隐藏的，在工具–》文件夹选项–》查看里，把对勾去掉</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041430089.png"></p><p>之后打开boot文件，这里提供一种解决方案；<br>[boot loader]<br>timeout&#x3D;5<br>default&#x3D;multi(0)disk(0)rdisk(0)partition(1)\WINDOWS<br>[operating systems]<br>multi(0)disk(0)rdisk(0)partition(1)\WINDOWS&#x3D;“Aaron [windbg]” &#x2F;noexecute&#x3D;optin &#x2F;fastdetect &#x2F;debug &#x2F;debugport&#x3D;com1 &#x2F;baudrate&#x3D;115200<br>将这个复制替换进去；其中的WINDOWS&#x3D;”这里是开机启动选项的名字，不太重要；<br>配置好这里后，让虚拟机关机，开始设置串行端口；</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041430033.png"></p><p>这里和我的保持一致就好了，如果没有串行端口，点击添加就好了；需要注意的是这里的com_1需要和tool文件里的com1一致，想要了解自己的虚拟机端口，将鼠标放到这里就可以看到；</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041431958.png"></p><p>3。这一步就到了设置windbg了<br>来到本机，我这里用的快捷方式，也可以进软解后添加；这里说快捷方式；右键属性，把 -b -k com:pipe,port&#x3D;.\pipe\com_1,baud&#x3D;115200,reconnect -y添加到目标地址中去；</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041431966.png"></p><p>接下来打开软件，会是这样的；</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041431530.png"></p><p>在打开刚刚调好的虚拟机，就会变成这样的界面；</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041432776.png"></p><p>然后调用命令时候发现会提示没有字符需要下载，由于国内以经下载不到了，需要一个梯子，不过这里我已经下载好了；符号下载地址：<a href="https://pan.baidu.com/s/1vgYjWUYTwtb4MZVUu1P-8A">https://pan.baidu.com/s/1vgYjWUYTwtb4MZVUu1P-8A</a> 提取码：0nou<br>下载好之后；双击打开，然后回默认安装到路径为<br>C:\Windows\Symbols下（不介意修改，后面后用到）<br>下一步需要加载到windbg上了<br>安装好之后，在windbg的这个位置</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041432242.png"></p><p>打开添加完整的符号路径<br>C:\Windows\Symbols;srvd:\symcache<a href="http://msdl.microsoft.com/download/symbols">http://msdl.microsoft.com/download/symbols</a></p><p>其中C:\Windows\Symbols;为符号文件下载路径，文件路径之间以分号隔开。如果设置不一样，需要自己定义路径；</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041432221.png"></p><p>这里的Reload需要点上，就会重新加载；其他的就是windbg的使用了，</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041433971.png"></p><p>这俩个地方就是一个让虚拟机运行，一个下断点的地方，使用就不多说了~</p><p>总结：容易出错的地方是：1，串行端口的com1的地方设置可能会出错，如果不会的话，那就和我设置成一样的；2.tool文件的设置，由于是系统文件，设置错误可能会导致蓝屏；3，符号文件的下载，网上的文章可能发布时间早，在微软符号还开放的时候发布的，什么设置环境，微软下载路径都以经不能用了，直接从链接里下载就没问题了；</p><p>符号下载地址：<a href="https://pan.baidu.com/s/1vgYjWUYTwtb4MZVUu1P-8A">https://pan.baidu.com/s/1vgYjWUYTwtb4MZVUu1P-8A</a> 提取码：0nou</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows核心编程对于临界区的详细描述</title>
      <link href="/2024/04/04/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E5%AF%B9%E4%BA%8E%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0/"/>
      <url>/2024/04/04/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E5%AF%B9%E4%BA%8E%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>&lt;如果图片长时间未显示，可能需要魔法&gt;</li></ul><p>临界区是指一个小代码段，在代码执行前能够独占某些资源的访问权；需要注意的是，系统仍然能够控制线程的运行，去安排其他线程。不过，在线程退出临界区之前，系统不会调度其他试图访问相同资源的线程。来看一段代码：</p><pre><code class="c++">const int p = 1000;//对这个全局变量进行操作int g_index = 0;DWORD g_time[p];DWORD WINAPI Thread1(DWORD pParam) &#123;    while (g_index&lt;p)    &#123;        g_time[g_index] = GetTickCount();//检索自系统启动以来经过的毫秒数        g_index++;    &#125;    return 0;&#125;DWORD WINAPI Thread2(DWORD pParam) &#123;    while (g_index &lt; p) &#123;        g_index++;        g_time[g_index - 1] = GetTickCount();    &#125;    return 0;&#125;</code></pre><p>这俩个函数如果单独执行，会产生相同的结果；如果在一个只有一个处理器的机器上跑，系统可能会先调用Thread2，当线程执行完g_index++后，cpu时间片耗尽要切换到Thread1，当这个线程的GetTickCount()获取时间时会将g_thime[1]设置为系统时间，然后再讲cpu分配到Thread2，它会将g_time[0]设置为系统时间；这样时间长的反而会被设置为0，短的设置为1，和预期结果是不一样的，这种线程安全问题会给后期的检查工作带来极大的麻烦。我们使用临界区去解决这个问题：</p><pre><code class="c++">const int p = 1000;//对这个全局变量进行操作int g_index = 0;DWORD g_time[p];CRITICAL_SECTION g_cs;//创建临界区对象DWORD WINAPI Thread1(DWORD pParam) &#123;    while (g_index&lt;p)    &#123;        EnterCriticalSection(&amp;g_cs);//进入临界区        g_time[g_index] = GetTickCount();//检索自系统启动以来经过的毫秒数        g_index++;        LeaveCriticalSection(&amp;g_cs);//离开临界区    &#125;    return 0;&#125;DWORD WINAPI Thread2(DWORD pParam) &#123;    while (g_index &lt; p) &#123;        EnterCriticalSection(&amp;g_cs);//进入临界区        g_index++;        g_time[g_index - 1] = GetTickCount();        LeaveCriticalSection(&amp;g_cs);//离开临界区    &#125;    return 0;</code></pre><p>指定了一个CRITICAL_SECTION 结构用来保护所有的资源，用EnterCriticalSection和LeaveCriticalSection函数将可能会共享资源的代码包裹住，这两个函数都调用了结构体的地址。</p><p>如果有多个不是一道使用的资源，比如1和2访问一个资源，1和3访问另外一个，这样需要为每一个资源创建一个独立的CRITICAL_SECTION结构。这个结构用来标识需要进入的线程，而EnterCriticalSection用来标识这个线程是否有人在使用。要记住在离开临界区时一定要调用LeaveCriticalSection，不然其他线程还是无法访问资源。</p><p>在无法使用互锁函数解决同步问题时，需要用到临界区。临界区的优点是使用容易，在内部使用互锁函数，因此能够快速运行。它的缺点是无法使用它们对多个进程中各个线程进行同步。</p><p>在了解完临界区的第一阶段之后，进入临界区的第二阶段，进入底层了解原理<br>先从第一个疑点，CRITIACAL_SECTION结构说起。当你用F1查看这个结构时，你只能看到结构成员，成员从哪来并不知道。因为微软认为你没有必要了解这个结构。CRITICAL_SECTION在WinNT.h中定义为RTL_CRITICAL_SECTION,这个结构也爱WinBase中做了定义、但是绝不应该编写引用这些成员的代码。</p><p>想要使用CRITIACAL_SECTION结构需要一个windows函数，那这个函数是如何对结构体成员进行操控的？</p><p>使用这个结构体有俩个要求：</p><p>需要访问这个资源的线程必须要知道负责保护线程的CRITICAL_SECTION结构我的地址，这个地址可以使用任何方法获取。<br>CRITICAL_SECTION结构中的成员应该在被访问前对成员进行初始化。函数为VOID IniticlizeCriticalSection(PCRITICAL_SECTION pcs);<br>这个函数只是对结构体的某些成员做了初始化，所以运行并不会失败，如果一个线程进入了一个未初始化的CRITICAL_SECTION结构，后果是不可预测的。<br>当没有线程需要访问资源是，需要调用函数清楚CRITICAL_SECTION结构：VOID DeleteCriticalSection(PCRITION pcs);</p><p>前面说过EnterCriticalSecion怎么使用现在说一下为什么这么使用：这个函数负责查看这个结构体中的成员变量，然后进行如下测试：后面为了方便这个函数使用ECS函数代替；</p><p>如果没有线程访问资源，ECS就更新成员变量。告诉线程能够单独访问这个资源。<br>如果成员变量指明线程已经被赋予对资源的访问权，ECS就更新成员变量，说明线程被赋予了多少次访问权并且立即返回，使现车个继续运行。这种情况很少见，只有当线程在一行中调用俩次ECS函数并且不影响LeaveCriticalSection函数的调用，才会出现这种情况。<br>如果成员变量指明，这个资源在被调用之前就有别的线程获取了访问权，那ECS将调用线程置于等待状态。等待线程不会浪费cpu。当这个资源调用了LeaveCritiolSecton释放资源后，这个线程就会从等待状态恢复为可调度状态。<br>有一种极端情况，如果在多处理器上俩个线程在同一时刻调用ECS函数，那这个函数还有用吗？  答案是有用，还是会将一个线程赋予资源访问权，有一个线程进入等待。因为这个函数的所有测试操作都是以原子方式进行的。<br>如果ECS函数将一个线程置于等待状态，要是在编写不好的程序中这个线程永远不会被调用，这个线程被称为渴求线程。但是在实际操作中，永远也不会出现这种情况。在注册表中CriticalSectionTimeout数据值决定的。如果请求时间超过这个时间，就会产生一个异常条件。这个函数其实可以用更方便的一个函数来代替:BOOL TryEnterCriticalSection(PCRITICAL_SECTION pcs);</p><p>这个不允许进入等待状态，它的返回值能够指明调用线程是否能够获取资源的访问权。如果发现有别的线程在访问资源，句返回FALSE，其他条件都会返回TRUE。要注意的是这个函数在windows 98中并没有实现，调用总会返回FALSE。</p><p>再来认识一个函数：WaitForSingleObject。<br>当WaitForSingleObject函数的第一个参数从未通知状态别为已通知状态时，在这个函数之下的WaitForSingleObject就不会在等待；线程正在运行为未通知状态，反正为已通知；这个函数等待单个对象，WaitForMultipleObjects()函数等待多个对象；第三个参数如果是true，会等待所有线程都执行完才会往下跑，如果是false，只要有任何一个线程变为已通知就会往下跑；</p><p>再来看在结尾处需要调用的函数LeaveCriticalSection函数的使用：这个函数没调用一次计数就会减1，如果这个计数大于0，那么这个函数不做其他操作，只返回。如果为0，就会查看在EnterCriticalSection中是否有其他线程在等待，如果至少有一个线程在等待，它就会先更新成员变量，将其中一个线程变为可调度状态。如果没有线程在等待，这个函数也会更新成员变量说明情况。</p><p>LeaveCriticalSection函数和EnterCriticalSection函数一样都可以以原子操作执行所有这些测试和更新，不过LeaveCriticalSection从不会使线程进入等待状态。当线程进入等待状态时，意味着线程必须从用户模式转为内核状态，这种转换消耗巨大。</p><p>在来看临界区的另外一种情况：在内存不足的情况下，可能会争临界区，同时系统也无法创建必要的事件内核对象，这是EnterCriticalSection会产生一个EXCEPTION_INVALID_HANDLE异常，这种情况非常少见，有俩种方法可以对这种情况进行处理。</p><p>可以使用结构化异常处理方式来跟踪错误。当初五发生时，可以不访问临界区保护的资源，可以等待某些内存变为可用状态时，再次调用EnterCriticalSection函数。<br>可以使用InitializeCriticalSectionAndSpinCount函数创建代码段，函数解释可以在vs中选中按F1进行查看，该函数要确保设置了dwSpinCount参数的高位。如果设置了，就创建事件内核对象。并且在初始化时和临界区关联起来。如果事件无法创建，就返回FALSE。如果事件创建成功，那EnterCriticalSection函数始终都能够运行。<br>关于临界区的使用技巧：<br>1.每个共享资源使用一个CRITICAL_SECTION变量</p><pre><code class="c++">DWORD g_time[100];DWORD g_name[100];CRITICAL_SECTION g_cs;//创建临界区对象DWORD WINAPI Thread1(DWORD pParam) &#123;    EnterCriticalSection(&amp;g_cs);    for (int i = 0; i &lt; 100; i++) &#123;        g_name[i] = 0;    &#125;    for (int i = 0; i &lt; 100; i++) &#123;        g_time[i] = &#39;x&#39;;    &#125;    LeaveCriticalSection(&amp;g_cs);    return 0;&#125;</code></pre><p>这段代码在理论上是讲，俩个数组初始化没有联系，在初始化数组g_name后，另一个只需要访问g_name数组而不是访问g_time数组的线程就可以执行了，同时Thread1可以继续对g_time数组进行初始化，但是这是不可能的，因为用一个临界区保护着这俩个数据结构。这种情况就需要创建俩个临界区分别初始化：</p><pre><code class="c++">DWORD g_time[100];CRITICAL_SECTION g_csTime;//创建临界区对象DWORD g_name[100];CRITICAL_SECTION g_csName;//创建临界区对象DWORD WINAPI Thread1(DWORD pParam) &#123;    EnterCriticalSection(&amp;g_csTime);    for (int i = 0; i &lt; 100; i++) &#123;        g_name[i] = 0;    &#125;    LeaveCriticalSection(&amp;g_csTime);​EnterCriticalSection(&amp;g_csName);​for (int i = 0; i &lt; 100; i++) &#123;​g_time[i] = &#39;x&#39;;​&#125;​LeaveCriticalSection(&amp;g_csName);​return 0;&#125;</code></pre><p>这个代码一旦完成了对g_name数组的初始化，另一个线程就可以开始使用g_name数组。</p><p>2.同时访问多个资源</p><pre><code class="c++">DWORD WINAPI Thread1(DWORD pParam) &#123;    EnterCriticalSection(&amp;g_csTime);    EnterCriticalSection(&amp;g_csName);    for (int i = 0; i &lt; 100; i++) &#123;        g_name[i] = g_time[i];    &#125;        LeaveCriticalSection(&amp;g_csName);    LeaveCriticalSection(&amp;g_csTime);​return 0;&#125;</code></pre><p>如果另外一个函数中的一个进程也要访问这俩个资源：</p><pre><code class="c++">DWORD WINAPI Thread2(DWORD pParam) &#123;    EnterCriticalSection(&amp;g_csName);    EnterCriticalSection(&amp;g_csTime);    for (int i = 0; i &lt; 100; i++) &#123;        g_name[i] = g_time[i];    &#125;        LeaveCriticalSection(&amp;g_csName);    LeaveCriticalSection(&amp;g_csTime);​return 0;&#125;</code></pre><p>这个函数切换了进入临界区的顺序，就有可能产生死锁。Thread1先获得g_csTime的所有权，当线程切换到Thread2时，先获得了g_csName的所有权，当cpu再次到thread1的时候，就会发生死锁，谁都无法获得另一个临界区的所有权。</p><p>解决这个问题，必须始终按照完全相同的顺序请求对资源的访问。</p><p>3.不要在临界区长时间运行同一个线程</p><p>如果无法确定在处理消息需要花费多长时间，可能几个毫秒，可能需要几年。这样的程序就是有问题的。C++</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows临界区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>植物大战僵尸无冷却方式</title>
      <link href="/2024/04/04/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E6%97%A0%E5%86%B7%E5%8D%B4%E6%96%B9%E5%BC%8F/"/>
      <url>/2024/04/04/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E6%97%A0%E5%86%B7%E5%8D%B4%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>&lt;如果图片长时间未显示，可能需要魔法&gt;</li></ul><p><strong>适用于大部分类型游戏，包括stream。</strong><br>要在太阳只够的情况下解决冷却问题，这是他的血量基址 </p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041345758.webp"></p><p>用ce收太阳，这里收到俩个值，当然会有很多数据的情况，就需要太阳变动去反复搜索筛选。  </p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041345007.webp"></p><p>右键数据是什么该写了这个地址，然后变动太阳，得到这条指令。</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041345696.png"></p><p>接下来要追的数据是eax的值。点击详细信息，得到eax的值是1EBA5F00（不同的ip可能值会不一样，以自己的为准）。将得到的地址用ce搜索。会得到一堆数据，这里的筛选方法是变动的排除，相似数据较多的全部排除。剩下俩个数据。</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041345164.webp"></p><p>右键是什么访问了这个地址。会得到很多还在变动的值，ptr标明这是指针，点击详细信息，  </p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041352466.png"></p><p>说明这就是最后的地址了。所以最后的偏移是026B9DE8+768+5560.</p><p>现在说冷却的解决方法。<br>这里提供的方法是用0和1搜索，提示：冷却状态为0，无冷却为1。  </p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041349861.png"></p><p>这样几个回合下来，数据就剩下5个之内了。这里得到俩个数据，右键是什么改写了这个地址，然后进游戏让第一个元素变动后，会得到这个数据。</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041355698.png"></p><p>注意，得到的数据要有黑线花的这个数据，如果俩个数据都没有，那就只能重新搜一遍了。之后点击第一条指令。显示反汇编程序，点击工具里的自动反汇编。</p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041356013.png"></p><p>点击模板 —&gt;代码注入,点击ok.  </p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041357653.png"></p><p>确定注入就完成了无冷却！是不是有种很爽的感觉。就像这样。  </p><p><img src="https://raw.githubusercontent.com/Aaronback/picgo/main/202404041358744.png"></p>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
